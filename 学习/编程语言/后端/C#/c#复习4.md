
break 跳出最内层封装语句
cintinue 回到循环开始处
## 标签语句 ##
给语句增加一个标签允许控制从代码的其他部分转移到该语句
标签语句只允许在块内部
作用域：
它声明所在的块
任何嵌套在该块内部的块
## goto ##
goto语句无条件的转移控制到一个标签语句。
一般形式
goto Identifier;

goto语句可以跳到它本身所在块内的任何标签语句,或跳出到任何他被嵌套的块内的标签语句
不能跳入任何嵌套在该语句本身所在块内部的任何块。

## using语句 ##
某些类型的非托管对象有数量限制或很消耗系统资源，在代码使用完他们后要尽快释放。
using语句就是为了资源尽快适当的处置。
资源是指一个实现了System.IDisposable接口的类或结构
using(ResourceType Id1=Expr1)EmbeddedStatement
using(TextWriter tw1 = File.CreateText(""));

## 结构 ##
结构与类的区别
类是引用类型,而结构是值类型，
结构是隐式密封的,不能派生
在结构中初始化语句是不允许的。
与创建类相比有时候可以提高性能

## 枚举 ##
enum TrafficLight
{
Green,
Yellow,
Red
}

## 显示初始化一维数组 ##
int[] intArr = new int{10,20,30,40};

## clone方法 ##
Clone方法为数组进行浅复制,只是创建了数组本身的克隆。如果
是引用类型数组,它不会复制引用的对象。
克隆值类型数组会产生两个独立的数组
克隆引用类型数组会产生指向相同对象的两个数组。

int[] intArr1 = {1,2,3};
int[] intArr2 = (int[])intArr1.Clone()//返回一个object;
## c#中值类型和引用类型的区别 ##
每一个值类型都有一个独立的内存区域保存自己的值，调用它的时候调用的是他的值，而应用类型调用的是内存中的地址 
比如a1=18，这时候在内存中保存的是18，当把a1付给a2的时候，他们两个应用的是同一个内存空间，a2的值会保存为a1的值，当把a2改为20是，应为a1和a2引用的是同一个所以a1也变成20了，这是引用类型，
值类型是当把a1付给a2时会为a2在开一块新的空间保存a1的值。当把a2改成20时就会在a2的空间保存20，和a1就没关系了
它们的区别在于使用的内存位置不同：值类型数据存储在栈上，而引用类型数据存储在堆上。
值类型直接包含值，换言之，变量引用的位置就是值在内存中实际存储的位置。
引用类型并不直接存储值，它们存储的是对一个内存位置的引用（内存地址），要去那个位置才能找到真正的数据

## 委托 ##
可以认为委托是持有一个或多个对象的方法.
委托步骤:
声明一个委托类型。委托声明与方法相似,只是没有实现块。
使用该委托类型声明一个委托变量。
创建委托类型的对象，把它赋值给委托变量

## 声明委托类型 ##

delegate void  MyDel(int x)
关键字  返回类型 委托类型名 签名

上面的声明指定了MyDel类型的委托只会接收不返回值并且有单个int的参数的方法。

## 创建委托对象 ##
MyDel delVar
委托类型 变量

delvar = new MyDel(myInstObj.MyM1);//创建委托并保存引用
                    实例方法

