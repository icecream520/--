## 再调用方法中同步的等待任务 ##
调用方法可以调用任意多的异步方法并接受它们返回的Task对象，需要等待结果返回才继续执行下面的任务,为此Task类提供一个实例方法Wati,可以在Task对象中调用该方法。
## Task.Delay ##
对象将暂停其在线程中的处理,并在一定时间之后完成Thread.Sleep 阻塞现成不同，Task.Delay不会阻塞线程,线程可以继续处理其他工作。

## 在GUI程序中执行异步操作 ##
图形用户界面
GUI程序设计上要求所有显示变化都必须在主GUI线程中完成。
当到达await语句时,处理程序返回到调用方法,并从处理器行摘下,这时其他消息得以处理————包括处理程序已经压入队列的那两条,在空闲任务完成后，后续部分会被重新安排到线程上。

## Task.Yield ##
此方法创建一个立即返回的awaitable。等待一个Yield可以让异步方法在执行后续部分的同时返回到调用方法。离开当前的消息队列,回到队列末尾，让处理器有时间处理其他任务。


## BackgroundWorker类 ##
async/await 特性适合那些需要在后台完成的不相关的小任务。
新建一个线程,在后台持续运行以完成某项工作，并不时地与主线程进行通信. BackgroundWorker类就是为此而生的。

## 其他异步编程模式 ##
如果委托对象在调用列表中的只有一个方法。
委托类方法有两个 BeginInvoke和EndInvoke
调用BeginInvoke方法时，它开始在一个独立线程上执行引用方法，并且立即返回到原始线程。原始线程可以继续执行,而引用方法会在线程池的线程中并行执行。
程序获取异步方法的结果时,可以坚持BeginInvoke返回的IAsuncResult的IsCompleted属性或调用委托的EndInvoke方法来等待委托完成。

## 计时器 ##

Timer time = new Timer(回调的名字,传给回调的对象,在多少毫秒后调用,每多少毫秒调用一次)